<!DOCTYPE html><html>
<head>
<title>Test 32 sprites in a cycle animation</title>
<!--<meta name = "viewport" content = "user-scalable=no, width=device-width">-->
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"/>

    <script type="text/javascript" src="../vendors/glMatrix.js"></script>
    <script type="text/javascript" src="../vendors/webgl-utils.js"></script>
    <script type="text/javascript" src="../lib/webgl.js?65"></script>
    <script src="../sprite.js?1"></script>
    <script src="../lib/scrolling.js"></script>
    <script src="mapeditor/mapimport.js"></script>
    <script src="./celeste.js?1"></script>
    
		<script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script>

    <style>
.sjs{
  border:2px #999 solid;
  overflow: hidden;
  width: 100%;
  height: 100%;
}
html, body {
  overflow:hidden;
    width: 100%;
      height: 100%;
}
    </style>

    <script id="shader-vs" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        attribute vec2 aTextureCoord;

        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;

        uniform vec4 uBounds;

        varying vec2 vTextureCoord;

        void main(void) {
          gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
          //vTextureCoord = aTextureCoord - vec2(0.5/(uBounds.x+1.0),0.5/(uBounds.y+1.0));
          vTextureCoord = aTextureCoord;
        }
    </script>

    <script id="shader-fs" type="x-shader/x-fragment">
        #ifdef GL_ES
            precision highp float;
        #endif

        varying vec2 vTextureCoord;

        uniform sampler2D uSampler;
        uniform vec4 uColor;

        void main(void) {
            gl_FragColor = uColor * texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        }
    </script>

</head>
<body>

<!--<p>
Sprite.js, 32 animated sprites, rotation and scaling. <a
  href="https://github.com/batiste/sprite.js">Get the source</a>. <br>-->
system load <span id="load"></span>%  (<span id="fps"></span>FPS)
<!--
<br><a href="?canvas=1" id="canvas-mode">Use canvas engine.</a>
<a href="?html=1" id="html-mode">Use HTML engine</a>
<a href="?webgl=1" id="webgl-mode">Use WebGL engine (experimental)</a>
</p>
-->

</body>

<script>


var hasGP = false;
var repGP;
gamepad = {buttons: [], axes: [0,0,0,0,0,0,0,0,0,0,0]};

function load(src, callback) {
    var xobj = new XMLHttpRequest();
    xobj.onreadystatechange = function () {
        if (xobj.readyState == 4) {
            var text = xobj.responseText;
            callback(text);
        }
    }
    src = src + "?t=" + (new Date()).getTime();
    xobj.open('GET', src, true);
    xobj.send(null);
}


function canGame() {
  return "getGamepads" in navigator;
}

function updateGamepad() {
  if (hasGP) {
    var gp = navigator.getGamepads()[0];

    for(var i=0;i<gp.buttons.length;i++) {
      gamepad.buttons[i] = gp.buttons[i].pressed;
    }

    for(var i=0;i<gp.axes.length; i++) {
      gamepad.axes[i] = gp.axes[i];
    }
  }
}

function rumble(duration, strong = 1.0, weak = 1.0) {
  if (hasGP) {
    var gp = navigator.getGamepads()[0];
    if (gp.vibrationActuator) {
      gp.vibrationActuator.playEffect("dual-rumble", {
        duration, strongMagnitude: strong, weakMagnitude: weak
      });
    }
  }
}

RumbleLength = {
  Short: 0.1,
  Medium: 0.15,
  Long: 0.5,
}

RumbleStrength = {
  Strong: {strong: 0.7, weak: 1.0},
  Medium: {strong: 0.5, weak: 0.5},
  Light: {strong: 0.0, weak: 1.0},
}

function InputRumble(str = RumbleStrength.Strong, len = RumbleLength.Short) {
  return rumble(1000*len, str.strong, str.weak);
}

function initController() {
  if(canGame()) {

    //var prompt = "To begin using your gamepad, connect it and press any button!";
    //$("#gamepadPrompt").text(prompt);

    $(window).on("gamepadconnected", function() {
      hasGP = true;
      //$("#gamepadPrompt").html("Gamepad connected!");
      console.log("connection event");
      //repGP = window.setInterval(reportOnGamepad,1000/100);
    });

    $(window).on("gamepaddisconnected", function() {
      console.log("disconnection event");
      hasGP = false;
      //$("#gamepadPrompt").text(prompt);
      //window.clearInterval(repGP);
    });

    //setup an interval for Chrome
    var checkGP = window.setInterval(function() {
      //console.log('checkGP');
      if(navigator.getGamepads()[0]) {
        if(!hasGP) $(window).trigger("gamepadconnected");
        window.clearInterval(checkGP);
      }
    }, 500);
  }
}

surface = null;
input = null;

function randi(n) {
  return Math.floor(Math.random()*n);
}


window.touchmove = function(e) {
    e.preventDefault();
  }

window.onload = function() {

  //jumpGraceTime = 1.1;
  //jumpSpeed = 16*-20*1.5;
  //gravity = 16*9.8*5*1.5;
  MaxFall = 160;
  Gravity = 900;
  HalfGravThreshold = 40;

  FastMaxFall = 240;
  FastMaxAccel = 300;

  MaxRun = 90;
  RunAccel = 1000;
  RunReduce = 400;
  AirMult = .65;

  JumpGraceTime = 0.1;
  JumpSpeed = -105;
  JumpHBoost = 40;
  VarJumpTime = 0.2;
  CeilingVarJumpGrace = 0.05;

  WallJumpCheckDist = 3;
  WallJumpForceTime = .16;
  WallJumpHSpeed = MaxRun + JumpHBoost;

  WallSlideStartMax = 20;
  WallSlideTime = 1.2;

  DashSpeed = 240;
  EndDashSpeed = 160;
  EndDashUpMult = .75;
  DashTime = .15;
  DashCooldown = .2;
  DashRefillCooldown = .1;
  DashHJumpThruNudge = 6;
  DashCornerCorrection = 4;
  DashVFloorSnapDist = 3;
  DashAttackTime = .3;


  function GlobalScale() {
    return 3;
  }
  var bounds = [240, 160+20, 320*GlobalScale(), 180*GlobalScale()]


  
  function Approach(val, target, maxMove)
  {
    return (val > target) ? Math.max(val - maxMove, target) : Math.min(val + maxMove, target);
  }

    //scene = sjs.Scene({w:2*0.3*640, h:2*0.3*600, autoPause: false});
    scene = sjs.Scene({w:bounds[2], h:bounds[3], autoPause: false});
    facing = {x: 1, y: -1};
    sprite = {};
    player = {vx: 0, vy: 0, ax: 0, ay: Gravity,
      lastAim: {x: 1, y: 0},
      maxFall: 0.0,
      jumpGraceTimer: 0.0,
      varJumpTimer: 0.0,
      varJumpSpeed: 0.0,
      dashTimer: 0.0,
      dashCooldownTimer: 0.0,
      dashRefillCooldownTimer: 0.0,
      onGround: false,
      Dashes: 1,
      MaxDashes: 1,
    };

  function RefillDash()
  {
    if (player.Dashes < player.MaxDashes)
    {
      player.Dashes = player.MaxDashes;
      return true;
    }
    else
      return false;
  }

  scene.loadImages(['img/character.png', 'img/spritejs.png', 'img/zergling.png', 'img/tiles.png'], function() {

    input = scene.Input();
    input.enableCustomEvents = true;



  var local = false;
  switch(window.location.protocol) {
     case 'http:':
     case 'https:':
       local = false;
       break;
     case 'file:':
       local = true;
       break;
  }

      scene.main = main;

  if(local)
      sjs.map.loadMap('http://127.0.0.1:8000/rzr/rzr.json', scene, main);
  else
      sjs.map.loadMap('rzr/rzr.json', scene, main);


    let canvas = window.location.href.indexOf('canvas') != -1;
    let webgl = window.location.href.indexOf('webgl') != -1;

    let layer;
    if(canvas) {
        if (document.getElementById('canvas-mode')) document.getElementById('canvas-mode').style.display = 'none';
        layer = scene.Layer("layer", {useCanvas:true, w: scene.w, h: scene.h});
    } else if(webgl) {
        if (document.getElementById('webgl-mode')) document.getElementById('webgl-mode').style.display = 'none';
        layer = scene.Layer("layer", {useWebGL:true, w: scene.w, h: scene.h});
    } else {
        if (document.getElementById('html-mode')) document.getElementById('html-mode').style.display = 'none';
        layer = scene.Layer("layer", {useCanvas:false, w: scene.w, h: scene.h});
    }

    anims = {};

    // walk
    {
      let anim = anims.walk = {w: 40, h: 39, frames: []};
      for (let x = 0; x < 9; x++) {
        let frame = [];
        for (let y = 0; y < 7; y++) {
          let frame_border = 2;
          let frame_padding = 1;
          let frame_w = anim.w;
          let frame_h = anim.h;
          let frame_x = 2 + x*(frame_border+frame_padding+frame_w);
          let frame_y = 2 + y*(frame_border+frame_padding+frame_h);
          frame.push([frame_x, frame_y, 10]);
        }
        anim.frames.push(frame);
      }
    }

    // attack
    {
      let anim = anims.attack = {w: 40, h: 39, frames: []};
      for (let x = 0; x < 9; x++) {
        let frame = [];
        for (let y = 0; y < 5; y++) {
          let frame_border = 2;
          let frame_padding = 1;
          let frame_w = anim.w;
          let frame_h = anim.h;
          let frame_x = 2 + (x+0)*(frame_border+frame_padding+frame_w);
          let frame_y = 2 + (y+7)*(frame_border+frame_padding+frame_h);
          frame.push([frame_x, frame_y, 10]);
        }
        anim.frames.push(frame);
      }
    }

    // burrow
    {
      let anim = anims.burrow = {w: 40, h: 39, frames: []};
      let frame = [];
      for (let x = 0; x < 5; x++) {
        for (let y = 0; y < 1; y++) {
          let frame_border = 2;
          let frame_padding = 1;
          let frame_w = anim.w;
          let frame_h = anim.h;
          let frame_x = 2 + (x+0)*(frame_border+frame_padding+frame_w);
          let frame_y = 2 + (y+5+7)*(frame_border+frame_padding+frame_h);
          frame.push([frame_x, frame_y, 10]);
        }
      }
      anim.frames.push(frame);
    }

    // die
    {
      let anim = anims.die = {w: 65, h: 53, frames: []};
      let frame = [];
      for (let x = 0; x < 7; x++) {
        for (let y = 0; y < 1; y++) {
          let frame_border = 2;
          let frame_padding = 1;
          let frame_w = anim.w;
          let frame_h = anim.h;
          let frame_x = 2 + (x+0)*(frame_border+frame_padding+frame_w);
          let frame_y = 2 + 546 + 0*(frame_border+frame_padding+frame_h);
          frame.push([frame_x, frame_y, 10]);
        }
      }
      anim.frames.push(frame);
    }

      let sin_cycle = 0,
          ms_to_render = 0,
          average_ms = 0,
          load = document.getElementById('load'),
          fps = document.getElementById('fps');

    function main() {
      console.log('main');
      initController();
      celesteInit(scene, layer, () => {
        console.log('main2timeout');
        setTimeout(main2, 5000);
      });
    }

    function main2() {
        var offsetx = 0;
        var offsety = 0;

        if(surface)
            surface.remove();

        surface = sjs.ScrollingSurface(scene, scene.w, scene.h, function(layer, _x, _y) {
            sjs.map.paintOn(layer, _x, _y);
        });

        sjs.map.playerStart = sjs.map.playerStart || {x: 0, y: 0};

        surface.position(sjs.map.playerStart.x - surface.w / 2, sjs.map.playerStart.y - surface.h / 2);
        surface.update();


    sprites = [];
    let actions = [
      anims.walk,
      //anims.attack,
      //anims.burrow,
      //anims.die,
    ];

    for(let y=0; y<1; y++) {
      let px = 0;
      for(let x=0; x<1; x++) {
        let sp = scene.Sprite('img/zergling.png', layer);
        let anim = actions[randi(actions.length)];
        sp.size(anim.w, anim.h);
        sp.setYOffset(2);
        sp.move(-surface.x, -surface.y);
        sp.move(px + 10, 5 + (y * 60));
        sprites.push(sp);
        //let cycle = sjs.Cycle(anim.frames[randi(anim.frames.length)]);
        {
          sp.cycle_up = sjs.Cycle(anim.frames[0]);
          sp.cycle_dn = sjs.Cycle(anim.frames[anim.frames.length-1]);
          sp.cycle_lr = sjs.Cycle(anim.frames[Math.floor(anim.frames.length/2)]);
          sp.cycle = sp.cycle_lr;
          sp.cycle.addSprite(sp);
        }
        px += anim.w + 5;
      }
    }

      function hideAnim(anim) {
        let dt = ticker.lastTicksElapsed;
        for (let fs of anim.framesets) {
          for (let frame of fs) {
            if (frame && frame.sprite) {
              frame.sprite.setOpacity(0.0);
              //frame.sprite.setXScale(1.0);
              //frame.sprite.setYScale(1.0);
              frame.sprite.update();
            }
          }
        }
      }

      function updateAnim(anim, surface, {mx, my}, facing, pfacing) {
        let dt = ticker.lastTicksElapsed * Math.max(1,0.25*Math.sqrt(mx*mx+my*my));
        hideAnim(anim);
        if (!anim.playing) {
          anim.playing = {time: 0.0, i: 0};
          anim.playing.duration = anim.framesets[anim.playing.i].length;
        }
        if (false && anim.playing.time >= anim.playing.duration) {
          anim.playing.time -= anim.playing.duration;
          anim.playing.i = (anim.playing.i + 1) % anim.framesets.length;
          anim.playing.duration = anim.framesets[anim.playing.i].length;
        }
        anim.playing.time += 0.25*dt;
        let idx = Math.floor(anim.playing.time) % anim.framesets[anim.playing.i].length;
        let frame = anim.framesets[anim.playing.i][idx];
        if (frame && frame.sprite) {
          sprite = frame.sprite;
          frame.sprite.setOpacity(1.0);
          //let s = Math.max(frame.iw, frame.ih);
          //s -= s % 2;
          //s = 16;
          //frame.sprite.size(s, s);
          //frame.sprite.size(frame.iw, frame.ih);
          frame.sprite.size(frame.w, frame.h);
          //frame.sprite.scale(2,2);
          let lx = facing.x;
          let sx = 0.5*(frame.w / frame.iw);
          let sy = 0.5*(frame.h / frame.ih);
          //if (lx < 0)
            //frame.sprite.setX(0*-surface.x + scene.w/2 + frame.w - (16+frame.x*((lx<0)?-1:1)));
            //else
          frame.sprite.setBackgroundRepeat('no-repeat');
          frame.sprite.transformOrigin(lx*(frame.x-16+0*frame.iw*0.5), frame.y-32+0*frame.ih*0.5);
          frame.sprite.setX(0*-surface.x + 1*scene.w/2 + 0*16+0*frame.x + frame.w*((lx<0)?0:0));//*((lx<0)?-1:1));
          frame.sprite.setY(0*-surface.y + 1*scene.h/2 + 0*32+0*frame.y);
          //frame.sprite.scale(sx*lx, sy);
          let scale = GlobalScale();
          scale = 1.0;
          //scale += gamepad.axes[4]+1.0;
          let grow = 0;
          let gp = navigator.getGamepads()[0];
          let angle = 0;
          if (gp) {
            grow += gp.buttons[7].value*2;
            angle += gp.buttons[6].value*2;
            grow += gp.buttons[0].value*0.5;
          }
          scale += grow;
          frame.sprite.setAngle(angle);

          if (grow > 0) {
            grow = Math.min(grow, 1.0);
            rumble(1000*RumbleLength.Medium, grow, grow);
            //InputRumble(grow*RumbleStrength.Strong, RumbleLength.Medium);
          }
          frame.sprite.scale(scale*lx, scale*1.0);
          //frame.sprite.setColor("#faa");
          //frame.sprite.size(32, 32);
          frame.sprite.update();
          //console.log(frame.w / frame.sprite.img.width);
          //console.dir(frame);
          //console.log('main2');
        }
        /*
        for (let fs of x.framesets) {
          for (let frame of fs) {
            if (frame.sprite) {
              frame.sprite.update();
              break;
            }
          }
        }
        */
      }

      function isRunning() {
        return input.keyboard.ctrl;
      }

      function isJumping() {
        return input.keyboard.w || input.keyboard.space || gamepad.buttons[0] || gamepad.buttons[1];
      }

      function InputMove() {
        /*
        let pixels = 3;
        if(isRunning()) {
          pixels = 6;
        }
        */
        let pixels = 1;
        let mx = 0;
        let my = 0;
        if(gamepad.buttons[12] || input.keyboard.up)    my += -pixels;
        if(gamepad.buttons[13] || input.keyboard.down)  my += pixels;
        if(gamepad.buttons[14] || input.keyboard.left)  mx += -pixels;
        if(gamepad.buttons[15] || input.keyboard.right) mx += pixels;
        if(Math.abs(gamepad.axes[0])>0.05)      mx += pixels*gamepad.axes[0];
        if(Math.abs(gamepad.axes[1])>0.05)      my += pixels*gamepad.axes[1];
        return {mx, my};
      }

      function InputGetAimVector(facing) {
        let {mx, my} = InputMove();
        if (!mx && !my) {
          mx = facing.x;
        }
        let len = Math.sqrt(mx*mx+my*my);
        return {x: mx/len, y: my/len};
        //return {x: mx, y: my};
      }

      function Jump(mx) {
        player.jumpGraceTimer = 0;
        player.varJumpTimer = VarJumpTime;
        player.dashAttackTimer = 0;
        player.wallSlideTimer = WallSlideTime;
        player.wallBoostTimer = 0;

        //player.vx += JumpHBoost * player.moveX;
        player.vy = JumpSpeed;
        //Speed += LiftBoost;
        player.varJumpSpeed = player.vy;
      }

      function DashPressed() {
        return input.keyboard.f || input.keyboard.enter || gamepad.buttons[1] || gamepad.buttons[2];
      }

      function CanDash()
      {
        return DashPressed() && player.dashCooldownTimer <= 0 && player.Dashes > 0/*&&  &&
          (TalkComponent.PlayerOver == null || !Input.Talk.Pressed);*/
      }

      function StartDash()
      {
        player.wasDashB = player.Dashes === 2;
        player.Dashes = Math.max(0, (player.Dashes || 0) - 1);
        DashBegin();
        Dash();
      }

      function DashBegin()
      {
          player.calledDashEvents = false;
          player.dashStartedOnGround = player.onGround;
          player.launched = false;

          //if (Engine.TimeRate > 0.25f)
              //Celeste.Freeze(.05f);
          player.dashTimer = DashTime;
          player.dashCooldownTimer = DashCooldown;
          player.dashRefillCooldownTimer = DashRefillCooldown;
          player.StartedDashing = true;
          player.wallSlideTimer = WallSlideTime;
          player.dashTrailTimer = 0;

          //level.Displacement.AddBurst(Center, .4f, 8, 64, .5f, Ease.QuadOut, Ease.QuadOut);

          InputRumble(RumbleStrength.Strong, RumbleLength.Medium);

          player.dashAttackTimer = DashAttackTime;
          player.beforeDashSpeed = {x: player.vx, y: player.vy};
          player.vx = 0; player.vy = 0;
          player.DashDir = {x: 0, y: 0};

          if (!player.onGround && player.Ducking && player.CanUnDuck)
              player.Ducking = false;
      }

      function Dash() {
        let dir = Object.assign({}, player.lastAim);
        let newSpeed = {x: dir.x * DashSpeed, y: dir.y * DashSpeed};
        if (Math.sign(player.beforeDashSpeed.x) == Math.sign(newSpeed.x) && Math.abs(player.beforeDashSpeed.x) > Math.abs(newSpeed.x)) {
            newSpeed.x = player.beforeDashSpeed.x;
        }
        console.log(newSpeed.x, newSpeed.y);
        player.vx = newSpeed.x;
        player.vy = newSpeed.y;

        player.DashDir = dir;
        player.DashSpeed = newSpeed;
        //SceneAs<Level>().DirectionalShake(DashDir, .2f);

        if (player.DashDir.x != 0) {
          facing.x = Math.sign(player.DashDir.x);
        }

        //CallDashEvents();
      }

      function updateMovement() {
        let dt = ticker.lastTicksElapsed*ticker.tickDuration/1000.0;
        let dT = dt * 1.5;

        //let {mx, my} = nputMove();
        let {mx, my} = InputMove();

        if (CanDash() && !player.wasDash) {
          player.wasDash = true;
          StartDash();
        }

        if (player.wasDash && !DashPressed()) {
          player.wasDash = false;
        }

        //Running and Friction
        if (player.Ducking && player.onGround)
          player.vx = Approach(player.vx, 0, DuckFriction * dT);
        else
        {
          let mult = player.onGround ? 1 : AirMult;
          /*
          if (player.onGround && level.CoreMode == Session.CoreModes.Cold)
            mult *= .3f;
            */

          //let max = Holding == null ? MaxRun : HoldingMaxRun;
          let max = MaxRun;
          //if (level.InSpace)
            //max *= SpacePhysicsMult;
          if (Math.abs(player.vx) > max && Math.sign(player.vx) == mx)
            player.vx = Approach(player.vx, max * mx, RunReduce * mult * dT);  //Reduce back from beyond the max speed
          else
            player.vx = Approach(player.vx, max * mx, RunAccel * mult * dT);   //Approach the max speed
        }

        //Calculate current max fall speed
        {
          let mf = MaxFall;
          let fmf = FastMaxFall;
          let Input = {MoveY: Math.sign(my)};

          /*
          if (level.InSpace)
          {
            mf *= SpacePhysicsMult;
            fmf *= SpacePhysicsMult;
          }
          */

          //Fast Fall
          if (Input.MoveY == 1 && player.vy >= mf)
          {
            player.maxFall = Approach(player.maxFall, fmf, FastMaxAccel * dT);

            /*
            let half = mf + (fmf - mf) * .5;
            if (player.vy >= half)
            {
              let spriteLerp = Math.Min(1, (player.vy - half) / (fmf - half));
              Sprite.Scale.X = MathHelper.Lerp(1, .5, spriteLerp);
              Sprite.Scale.Y = MathHelper.Lerp(1, 1.5, spriteLerp);
            }
            */
          }
          else {
            player.maxFall = Approach(player.maxFall, mf, FastMaxAccel * dT);
          }
        }

        //player.vx += dT*player.ax;
        //player.vy += dT*player.ay;
        if (!player.onGround) {
          let max = player.maxFall;
          let mult = 0.5;
          player.vy = Approach(player.vy, max, Gravity * mult * dT);
        }

        if (player.onGround) {
          player.jumpGraceTimer = JumpGraceTime;
        } else if (player.jumpGraceTimer > 0) {
          player.jumpGraceTimer -= dt;
        }
        //player.jumpGraceTimer = Math.max(0, player.jumpGraceTimer);
        //console.log(player.jumpGraceTimer);

        //if (player.vy > player.ay) { player.vy = player.ay; }

        let jumping = isJumping();


        //Variable Jumping
        if (player.varJumpTimer > 0)
        {
          //if (AutoJump || Input.Jump.Check)
          if (jumping)
            player.vy = Math.min(player.vy, player.varJumpSpeed);
          else
            player.varJumpTimer = 0;
        }

        if (jumping) {
          if (player.jumpGraceTimer > 0 && !player.wasJumping) {
            player.wasJumping = true;
            Jump();
          }
        } else {
          player.wasJumping = false;
        }

        //Dashes
        {
          if (player.dashTimer > 0) {
            player.dashTimer -= dt;
            if (player.dashTimer > 0) {
              player.vx = player.DashSpeed.x;
              player.vy = player.DashSpeed.y;
            } else {
              if (player.DashDir.y <= 0) {
                player.vx = player.DashDir.x * EndDashSpeed;
                player.vy = player.DashDir.y * EndDashSpeed;
              }
              if (player.vy < 0) {
                player.vy *= EndDashUpMult;
              }
            }
          }

          if (player.dashCooldownTimer > 0)
            player.dashCooldownTimer -= dt;

          if (player.dashRefillCooldownTimer > 0)
            player.dashRefillCooldownTimer -= dt;

          else {
            if (player.onGround) {
              RefillDash();
            }
          }
        }

        //Var Jump
        if (player.varJumpTimer > 0)
          player.varJumpTimer -= dt;

        //Aiming
        player.lastAim = InputGetAimVector(facing);

        if (sprite.x) {
          //let x = sprite.w/2 + sprite.x + surface.x;
          //let y = sprite.h/2 + sprite.y + surface.y;
          let x = 0*16 + sprite.x + surface.x;
          let y = 0*32 + sprite.y + surface.y;
          //let x = 32/2 + surface.x;
          //let y = 32/2 + surface.y;

          /*
          if (sjs.map.collides(x+player.vx*dT, y)) {
            player.vx = 0;
          } else {
          }
          */
          if (sjs.map.collides(x, y+player.vy*dT)) {
            player.onGround = player.vy > 0;
            player.vy = 0;
            //player.ay = 0;
          } else {
            player.onGround = false;
          }
        }

        //player.vx = mx;

        mx = player.vx*dT;
        my = player.vy*dT;
        return {mx, my};
      }

        //player.position(surface.w / 2 - player.w/2, surface.h / 2 - player.h);

        ticker = scene.Ticker(paint, {tickDuration: 1000/60, useAnimationFrame:true});
        ticker.run();

      function paint() {
        //console.log('paint');

          let start = new Date().getTime(),
              xv = 1*Math.sin(ticker.currentTick / 150) * 2,
              xscale = xv < 0 ? -1 : 1;

          let dt = ticker.lastTicksElapsed;

          let sx = (surface.x + surface.w / 2);
          let sy = (surface.y + surface.h / 2);

          updateGamepad();
          let {mx, my} = updateMovement();

        /*
          for(let i=0, sp; sp = sprites[i]; i++) {
            let x = sp.x + sp.w/2 + surface.x;
            let y = sp.y + sp.h/2 + surface.y;

            if (sjs.map.collides(x+mx*dt, y)) { mx=0; }
            if (sjs.map.collides(x, y+my*dt)) { my=0; }

            if (sjs.map.collides(x, y)) {
              sp.setOpacity(0.5);
            } else {
              sp.setOpacity(1.0);
            }

            if (sp.cycle) {
              if (mx < 0) {
                sp.scale(-1, 1);
                sp.cycle_up.removeSprite(sp);
                sp.cycle_dn.removeSprite(sp);
                sp.cycle_lr.addSprite(sp);
                sp.cycle_lr.next(0.75*-mx*dt);
              } else if (mx > 0) {
                sp.scale( 1, 1);
                sp.cycle_up.removeSprite(sp);
                sp.cycle_dn.removeSprite(sp);
                sp.cycle_lr.addSprite(sp);
                sp.cycle_lr.next(0.75*mx*dt);
              } else if (my < 0) {
                sp.cycle_lr.removeSprite(sp);
                sp.cycle_dn.removeSprite(sp);
                sp.cycle_up.addSprite(sp);
                sp.cycle_up.next(0.75*-my*dt);
              } else if (my > 0) {
                sp.cycle_lr.removeSprite(sp);
                sp.cycle_up.removeSprite(sp);
                sp.cycle_dn.addSprite(sp);
                sp.cycle_dn.next(0.75*my*dt);
              } else {
                sp.cycle_up.reset();
                sp.cycle_dn.reset();
                sp.cycle_lr.reset();
              }
            }
            sp.update();
          }
          */

          let pfacing = {x: facing.x, y: facing.y};

          surface.move(mx, my);
          surface.update();
          for (let anim of Object.values(celeste.anims)) {
            hideAnim(anim);
          }
          //updateAnim(celeste.anims.climbup, surface, {mx, my});
          if (mx) {
            facing.x = Math.sign(mx);
            if (isRunning()) {
              updateAnim(celeste.anims.runFast, surface, {mx, my}, facing, pfacing);
            } else {
              updateAnim(celeste.anims.walk, surface, {mx, my}, facing, pfacing);
            }
          } else if (my) {
            facing.y = Math.sign(my);
            if (my < 0) {
              //updateAnim(celeste.anims.climbup, surface, {mx, my}, facing, pfacing);
              updateAnim(celeste.anims.jumpSlow, surface, {mx, my}, facing, pfacing);
            } else {
              updateAnim(celeste.anims.fallSlow, surface, {mx, my}, facing, pfacing);
            }
          } else {
            updateAnim(celeste.anims.idleC, surface, {mx, my}, facing, pfacing);
          }

          if(fps && load && ticker.currentTick % 60 == 0) {
              load.innerHTML = ticker.load;
              fps.innerHTML = ticker.fps;
          }
      };
    }

    });

};
</script>
</html>
