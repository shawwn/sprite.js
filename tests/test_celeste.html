<!DOCTYPE html><html>
<head>
<title>Test 32 sprites in a cycle animation</title>
<!--<meta name = "viewport" content = "user-scalable=no, width=device-width">-->
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"/>

    <script type="text/javascript" src="../vendors/glMatrix.js"></script>
    <script type="text/javascript" src="../vendors/webgl-utils.js"></script>
    <script type="text/javascript" src="../lib/webgl.js"></script>
    <script src="../sprite.js"></script>
    <script src="../lib/scrolling.js"></script>
    <script src="mapeditor/mapimport.js"></script>
    <script src="./celeste.js"></script>
    
		<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script>

    <style>
.sjs{
  border:2px #999 solid;
  overflow: hidden;
  width: 100%;
  height: 100%;
}
html, body {
  overflow:hidden;
    width: 100%;
      height: 100%;
}
    </style>

    <script id="shader-vs" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        attribute vec2 aTextureCoord;

        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;

        varying vec2 vTextureCoord;

        void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
            vTextureCoord = aTextureCoord;
        }
    </script>

    <script id="shader-fs" type="x-shader/x-fragment">
        #ifdef GL_ES
            precision highp float;
        #endif

        varying vec2 vTextureCoord;

        uniform sampler2D uSampler;

        void main(void) {
            gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        }
    </script>

</head>
<body>

<!--<p>
Sprite.js, 32 animated sprites, rotation and scaling. <a
  href="https://github.com/batiste/sprite.js">Get the source</a>. <br>-->
system load <span id="load"></span>%  (<span id="fps"></span>FPS)
<!--
<br><a href="?canvas=1" id="canvas-mode">Use canvas engine.</a>
<a href="?html=1" id="html-mode">Use HTML engine</a>
<a href="?webgl=1" id="webgl-mode">Use WebGL engine (experimental)</a>
</p>
-->

</body>

<script>


var hasGP = false;
var repGP;
gamepad = {buttons: [], axes: [0,0,0,0,0,0,0,0,0,0,0]};

function load(src, callback) {
    var xobj = new XMLHttpRequest();
    xobj.onreadystatechange = function () {
        if (xobj.readyState == 4) {
            var text = xobj.responseText;
            callback(text);
        }
    }
    src = src + "?t=" + (new Date()).getTime();
    xobj.open('GET', src, true);
    xobj.send(null);
}


function canGame() {
  return "getGamepads" in navigator;
}

function reportOnGamepad() {
  var gp = navigator.getGamepads()[0];
  
  for(var i=0;i<gp.buttons.length;i++) {
    gamepad.buttons[i] = gp.buttons[i].pressed;
  }
  
  for(var i=0;i<gp.axes.length; i++) {
    gamepad.axes[i] = gp.axes[i];
  }
}

function initController() {
  if(canGame()) {

    //var prompt = "To begin using your gamepad, connect it and press any button!";
    //$("#gamepadPrompt").text(prompt);

    $(window).on("gamepadconnected", function() {
      hasGP = true;
      //$("#gamepadPrompt").html("Gamepad connected!");
      console.log("connection event");
      repGP = window.setInterval(reportOnGamepad,1000/10);
    });

    $(window).on("gamepaddisconnected", function() {
      console.log("disconnection event");
      //$("#gamepadPrompt").text(prompt);
      window.clearInterval(repGP);
    });

    //setup an interval for Chrome
    var checkGP = window.setInterval(function() {
      //console.log('checkGP');
      if(navigator.getGamepads()[0]) {
        if(!hasGP) $(window).trigger("gamepadconnected");
        window.clearInterval(checkGP);
      }
    }, 500);
  }
}

surface = null;
input = null;

function randi(n) {
  return Math.floor(Math.random()*n);
}


window.touchmove = function(e) {
    e.preventDefault();
  }

window.onload = function() {

  //jumpGraceTime = 1.1;
  //jumpSpeed = 16*-20*1.5;
  //gravity = 16*9.8*5*1.5;
  MaxFall = 160;
  Gravity = 900;
  HalfGravThreshold = 40;

  FastMaxFall = 240;
  FastMaxAccel = 300;

  MaxRun = 90;
  RunAccel = 1000;
  RunReduce = 400;
  AirMult = .65;

  JumpGraceTime = 0.1;
  JumpSpeed = -105;
  JumpHBoost = 40;
  VarJumpTime = 0.2;
  CeilingVarJumpGrace = 0.05;

  WallJumpCheckDist = 3;
  WallJumpForceTime = .16;
  WallJumpHSpeed = MaxRun + JumpHBoost;

  WallSlideStartMax = 20;
  WallSlideTime = 1.2;

  
  function Approach(val, target, maxMove)
  {
    return (val > target) ? Math.max(val - maxMove, target) : Math.min(val + maxMove, target);
  }

    scene = sjs.Scene({w:2*0.3*640, h:2*0.3*600, autoPause: false});
    facing = {x: 1, y: -1};
    sprite = {};
    player = {vx: 0, vy: 0, ax: 0, ay: Gravity,
      maxFall: 0.0,
      jumpGraceTimer: 0.0,
      varJumpTimer: 0.0,
      varJumpSpeed: 0.0,
      onGround: false,
    };

    scene.loadImages(['img/character.png', 'img/spritejs.png', 'img/zergling.png', 'img/tiles.png'], function() {

    input = scene.Input();
    input.enableCustomEvents = true;



  var local = false;
  switch(window.location.protocol) {
     case 'http:':
     case 'https:':
       local = false;
       break;
     case 'file:':
       local = true;
       break;
  }

      scene.main = main;

  if(local)
      sjs.map.loadMap('http://127.0.0.1:8000/rzr/rzr.json', scene, main);
  else
      sjs.map.loadMap('rzr/rzr.json', scene, main);


    let canvas = window.location.href.indexOf('canvas') != -1;
    let webgl = window.location.href.indexOf('webgl') != -1;

    let layer;
    if(canvas) {
        if (document.getElementById('canvas-mode')) document.getElementById('canvas-mode').style.display = 'none';
        layer = scene.Layer("layer", {useCanvas:true});
    } else if(webgl) {
        if (document.getElementById('webgl-mode')) document.getElementById('webgl-mode').style.display = 'none';
        layer = scene.Layer("layer", {useWebGL:true});
    } else {
        if (document.getElementById('html-mode')) document.getElementById('html-mode').style.display = 'none';
        layer = scene.Layer("layer", {useCanvas:false});
    }

    anims = {};

    // walk
    {
      let anim = anims.walk = {w: 40, h: 39, frames: []};
      for (let x = 0; x < 9; x++) {
        let frame = [];
        for (let y = 0; y < 7; y++) {
          let frame_border = 2;
          let frame_padding = 1;
          let frame_w = anim.w;
          let frame_h = anim.h;
          let frame_x = 2 + x*(frame_border+frame_padding+frame_w);
          let frame_y = 2 + y*(frame_border+frame_padding+frame_h);
          frame.push([frame_x, frame_y, 10]);
        }
        anim.frames.push(frame);
      }
    }

    // attack
    {
      let anim = anims.attack = {w: 40, h: 39, frames: []};
      for (let x = 0; x < 9; x++) {
        let frame = [];
        for (let y = 0; y < 5; y++) {
          let frame_border = 2;
          let frame_padding = 1;
          let frame_w = anim.w;
          let frame_h = anim.h;
          let frame_x = 2 + (x+0)*(frame_border+frame_padding+frame_w);
          let frame_y = 2 + (y+7)*(frame_border+frame_padding+frame_h);
          frame.push([frame_x, frame_y, 10]);
        }
        anim.frames.push(frame);
      }
    }

    // burrow
    {
      let anim = anims.burrow = {w: 40, h: 39, frames: []};
      let frame = [];
      for (let x = 0; x < 5; x++) {
        for (let y = 0; y < 1; y++) {
          let frame_border = 2;
          let frame_padding = 1;
          let frame_w = anim.w;
          let frame_h = anim.h;
          let frame_x = 2 + (x+0)*(frame_border+frame_padding+frame_w);
          let frame_y = 2 + (y+5+7)*(frame_border+frame_padding+frame_h);
          frame.push([frame_x, frame_y, 10]);
        }
      }
      anim.frames.push(frame);
    }

    // die
    {
      let anim = anims.die = {w: 65, h: 53, frames: []};
      let frame = [];
      for (let x = 0; x < 7; x++) {
        for (let y = 0; y < 1; y++) {
          let frame_border = 2;
          let frame_padding = 1;
          let frame_w = anim.w;
          let frame_h = anim.h;
          let frame_x = 2 + (x+0)*(frame_border+frame_padding+frame_w);
          let frame_y = 2 + 546 + 0*(frame_border+frame_padding+frame_h);
          frame.push([frame_x, frame_y, 10]);
        }
      }
      anim.frames.push(frame);
    }

      let sin_cycle = 0,
          ms_to_render = 0,
          average_ms = 0,
          load = document.getElementById('load'),
          fps = document.getElementById('fps');

    function main() {
      console.log('main');
      initController();
      celesteInit(scene, layer, () => {
        console.log('main2timeout');
        setTimeout(main2, 1000);
      });
    }

    function main2() {
        var offsetx = 0;
        var offsety = 0;

        if(surface)
            surface.remove();

        surface = sjs.ScrollingSurface(scene, scene.w, scene.h, function(layer, _x, _y) {
            sjs.map.paintOn(layer, _x, _y);
        });

        sjs.map.playerStart = sjs.map.playerStart || {x: 0, y: 0};

        surface.position(sjs.map.playerStart.x - surface.w / 2, sjs.map.playerStart.y - surface.h / 2);
        surface.update();


    sprites = [];
    let actions = [
      anims.walk,
      //anims.attack,
      //anims.burrow,
      //anims.die,
    ];

    for(let y=0; y<1; y++) {
      let px = 0;
      for(let x=0; x<1; x++) {
        let sp = scene.Sprite('img/zergling.png', layer);
        let anim = actions[randi(actions.length)];
        sp.size(anim.w, anim.h);
        sp.setYOffset(2);
        sp.move(-surface.x, -surface.y);
        sp.move(px + 10, 5 + (y * 60));
        sprites.push(sp);
        //let cycle = sjs.Cycle(anim.frames[randi(anim.frames.length)]);
        {
          sp.cycle_up = sjs.Cycle(anim.frames[0]);
          sp.cycle_dn = sjs.Cycle(anim.frames[anim.frames.length-1]);
          sp.cycle_lr = sjs.Cycle(anim.frames[Math.floor(anim.frames.length/2)]);
          sp.cycle = sp.cycle_lr;
          sp.cycle.addSprite(sp);
        }
        px += anim.w + 5;
      }
    }

      function hideAnim(anim) {
        let dt = ticker.lastTicksElapsed;
        for (let fs of anim.framesets) {
          for (let frame of fs) {
            if (frame && frame.sprite) {
              frame.sprite.setOpacity(0.0);
              //frame.sprite.setXScale(1.0);
              //frame.sprite.setYScale(1.0);
              frame.sprite.update();
            }
          }
        }
      }

      function updateAnim(anim, surface, {mx, my}, facing, pfacing) {
        let dt = ticker.lastTicksElapsed * Math.max(1,0.25*Math.sqrt(mx*mx+my*my));
        hideAnim(anim);
        if (!anim.playing) {
          anim.playing = {time: 0.0, i: 0};
          anim.playing.duration = anim.framesets[anim.playing.i].length;
        }
        if (false && anim.playing.time >= anim.playing.duration) {
          anim.playing.time -= anim.playing.duration;
          anim.playing.i = (anim.playing.i + 1) % anim.framesets.length;
          anim.playing.duration = anim.framesets[anim.playing.i].length;
        }
        anim.playing.time += 0.25*dt;
        let idx = Math.floor(anim.playing.time) % anim.framesets[anim.playing.i].length;
        let frame = anim.framesets[anim.playing.i][idx];
        if (frame && frame.sprite) {
          sprite = frame.sprite;
          frame.sprite.setOpacity(1.0);
          //let s = Math.max(frame.iw, frame.ih);
          //s -= s % 2;
          //s = 16;
          //frame.sprite.size(s, s);
          frame.sprite.size(frame.iw, frame.ih);
          //frame.sprite.scale(2,2);
          let lx = facing.x;
          let sx = 0.5*(frame.w / frame.iw);
          let sy = 0.5*(frame.h / frame.ih);
          frame.sprite.setX(0*-surface.x + scene.w/2 + frame.x*((lx<0)?0:1));
          frame.sprite.setY(0*-surface.y + scene.h/2 + frame.y);
          frame.sprite.scale(sx*lx, sy);
          //frame.sprite.size(32, 32);
          frame.sprite.update();
          //console.log(frame.w / frame.sprite.img.width);
          //console.dir(frame);
          //console.log('main2');
        }
        /*
        for (let fs of x.framesets) {
          for (let frame of fs) {
            if (frame.sprite) {
              frame.sprite.update();
              break;
            }
          }
        }
        */
      }

      function isRunning() {
        return input.keyboard.enter || input.keyboard.ctrl;
      }

      function isJumping() {
        return input.keyboard.space || gamepad.buttons[0] || gamepad.buttons[1];
      }

      function InputMove() {
        let pixels = 3;
        if(isRunning()) {
          pixels = 6;
        }
        let mx = 0;
        let my = 0;
        if(gamepad.buttons[12] || input.keyboard.up)    my += -pixels;
        if(gamepad.buttons[13] || input.keyboard.down)  my += pixels;
        if(gamepad.buttons[14] || input.keyboard.left)  mx += -pixels;
        if(gamepad.buttons[15] || input.keyboard.right) mx += pixels;
        if(Math.abs(gamepad.axes[0])>0.05)      mx += pixels*gamepad.axes[0];
        if(Math.abs(gamepad.axes[1])>0.05)      my += pixels*gamepad.axes[1];
        return {mx, my};
      }

      function Jump(mx) {
        player.jumpGraceTimer = 0;
        player.varJumpTimer = VarJumpTime;
        player.dashAttackTimer = 0;
        player.wallSlideTimer = WallSlideTime;
        player.wallBoostTimer = 0;

        //player.vx += JumpHBoost * player.moveX;
        player.vy = JumpSpeed;
        //Speed += LiftBoost;
        player.varJumpSpeed = player.vy;
      }

      function computeMovement() {
        let dt = ticker.lastTicksElapsed;
        //let dT = 1.5*dt*ticker.tickDuration/1000.0;
        let dT = 1.5*1*ticker.tickDuration/1000.0;

        let {mx, my} = InputMove();

        //Calculate current max fall speed
        {
          let mf = MaxFall;
          let fmf = FastMaxFall;
          let Input = {MoveY: Math.sign(my)};

          /*
          if (level.InSpace)
          {
            mf *= SpacePhysicsMult;
            fmf *= SpacePhysicsMult;
          }
          */

          //Fast Fall
          if (Input.MoveY == 1 && player.vy >= mf)
          {
            player.maxFall = Approach(player.maxFall, fmf, FastMaxAccel * dT);

            /*
            let half = mf + (fmf - mf) * .5;
            if (player.vy >= half)
            {
              let spriteLerp = Math.Min(1, (player.vy - half) / (fmf - half));
              Sprite.Scale.X = MathHelper.Lerp(1, .5, spriteLerp);
              Sprite.Scale.Y = MathHelper.Lerp(1, 1.5, spriteLerp);
            }
            */
          }
          else {
            player.maxFall = Approach(player.maxFall, mf, FastMaxAccel * dT);
          }
        }

        //player.vx += dT*player.ax;
        //player.vy += dT*player.ay;
        if (!player.onGround) {
          let max = player.maxFall;
          let mult = 0.5;
          player.vy = Approach(player.vy, max, Gravity * mult * dT);
        }

        if (player.onGround) {
          player.jumpGraceTimer = JumpGraceTime;
        } else if (player.jumpGraceTimer > 0) {
          player.jumpGraceTimer -= dT;
        }
        //player.jumpGraceTimer = Math.max(0, player.jumpGraceTimer);
        //console.log(player.jumpGraceTimer);

        //if (player.vy > player.ay) { player.vy = player.ay; }

        let jumping = isJumping();


        //Variable Jumping
        if (player.varJumpTimer > 0)
        {
          //if (AutoJump || Input.Jump.Check)
          if (jumping)
            player.vy = Math.min(player.vy, player.varJumpSpeed);
          else
            player.varJumpTimer = 0;
        }

        if (jumping) {
          if (player.jumpGraceTimer > 0 && !player.wasJumping) {
            player.wasJumping = true;
            Jump();
          }
        } else {
          player.wasJumping = false;
        }


        //Var Jump
        if (player.varJumpTimer > 0)
          player.varJumpTimer -= dT;

        if (sprite.x) {
          //let x = sprite.w/2 + sprite.x + surface.x;
          //let y = sprite.h/2 + sprite.y + surface.y;
          let x = 16/2 + sprite.x + surface.x;
          let y = 32/2 + sprite.y + surface.y;
          //let x = 32/2 + surface.x;
          //let y = 32/2 + surface.y;

          if (sjs.map.collides(x+player.vx*dT, y)) {
            player.vx = 0;
          } else {
          }
          if (sjs.map.collides(x, y+player.vy*dT)) {
            player.onGround = player.vy > 0;
            player.vy = 0;
            //player.ay = 0;
          } else {
            player.onGround = false;
          }
        }

        player.vx = mx;



        mx = player.vx;
        my = player.vy*dT;
        return {mx, my};
      }

        //player.position(surface.w / 2 - player.w/2, surface.h / 2 - player.h);

        ticker = scene.Ticker(paint, {tickDuration: 1000/60, useAnimationFrame:true});
        ticker.run();

      function paint() {
        //console.log('paint');

          let start = new Date().getTime(),
              xv = 1*Math.sin(ticker.currentTick / 150) * 2,
              xscale = xv < 0 ? -1 : 1;

          let dt = ticker.lastTicksElapsed;

          let sx = (surface.x + surface.w / 2);
          let sy = (surface.y + surface.h / 2);

          let {mx, my} = computeMovement();

        /*
          for(let i=0, sp; sp = sprites[i]; i++) {
            let x = sp.x + sp.w/2 + surface.x;
            let y = sp.y + sp.h/2 + surface.y;

            if (sjs.map.collides(x+mx*dt, y)) { mx=0; }
            if (sjs.map.collides(x, y+my*dt)) { my=0; }

            if (sjs.map.collides(x, y)) {
              sp.setOpacity(0.5);
            } else {
              sp.setOpacity(1.0);
            }

            if (sp.cycle) {
              if (mx < 0) {
                sp.scale(-1, 1);
                sp.cycle_up.removeSprite(sp);
                sp.cycle_dn.removeSprite(sp);
                sp.cycle_lr.addSprite(sp);
                sp.cycle_lr.next(0.75*-mx*dt);
              } else if (mx > 0) {
                sp.scale( 1, 1);
                sp.cycle_up.removeSprite(sp);
                sp.cycle_dn.removeSprite(sp);
                sp.cycle_lr.addSprite(sp);
                sp.cycle_lr.next(0.75*mx*dt);
              } else if (my < 0) {
                sp.cycle_lr.removeSprite(sp);
                sp.cycle_dn.removeSprite(sp);
                sp.cycle_up.addSprite(sp);
                sp.cycle_up.next(0.75*-my*dt);
              } else if (my > 0) {
                sp.cycle_lr.removeSprite(sp);
                sp.cycle_up.removeSprite(sp);
                sp.cycle_dn.addSprite(sp);
                sp.cycle_dn.next(0.75*my*dt);
              } else {
                sp.cycle_up.reset();
                sp.cycle_dn.reset();
                sp.cycle_lr.reset();
              }
            }
            sp.update();
          }
          */

          let pfacing = {x: facing.x, y: facing.y};

          surface.move(mx, my);
          surface.update();
          for (let anim of Object.values(celeste.anims)) {
            hideAnim(anim);
          }
          //updateAnim(celeste.anims.climbup, surface, {mx, my});
          if (mx) {
            facing.x = Math.sign(mx);
            if (isRunning()) {
              updateAnim(celeste.anims.runFast, surface, {mx, my}, facing, pfacing);
            } else {
              updateAnim(celeste.anims.walk, surface, {mx, my}, facing, pfacing);
            }
          } else if (my) {
            facing.y = Math.sign(my);
            if (my < 0) {
              //updateAnim(celeste.anims.climbup, surface, {mx, my}, facing, pfacing);
              updateAnim(celeste.anims.jumpSlow, surface, {mx, my}, facing, pfacing);
            } else {
              updateAnim(celeste.anims.fallSlow, surface, {mx, my}, facing, pfacing);
            }
          } else {
            updateAnim(celeste.anims.idle, surface, {mx, my}, facing, pfacing);
          }

          if(fps && load && ticker.currentTick % 60 == 0) {
              load.innerHTML = ticker.load;
              fps.innerHTML = ticker.fps;
          }
      };
    }

    });

};
</script>
</html>
